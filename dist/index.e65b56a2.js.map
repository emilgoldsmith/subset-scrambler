{"mappings":"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ACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAC1B,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAC1B,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAC1B,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAC1B,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAC1B,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EACX,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EACX,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAI,CACF,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAG,CACD,GAAI,CAAC,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAAE,AACF,EACA,CAEE,OAAQ,CAAC,EACX,EACA,EACA,EACA,EACA,EAAE,CACA,GAAI,CAAC,EACP,EACA,E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","sources":["<anon>","node_modules/cubejs/lib/cube.js","init.js","node_modules/cubejs/index.js","node_modules/cubejs/lib/solve.js"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"aPTAb\", function(module, exports) {\n(function() {\n    // Centers\n    var B, BL, BR, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, L, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, centerColor, centerFacelet, cornerColor, cornerFacelet, edgeColor, edgeFacelet;\n    [U, R, F, D, L, B] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5\n    ];\n    // Corners\n    [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7\n    ];\n    // Edges\n    [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11\n    ];\n    [centerFacelet, cornerFacelet, edgeFacelet] = function() {\n        var _B, _D, _F, _L, _R, _U;\n        _U = function(x) {\n            return x - 1;\n        };\n        _R = function(x) {\n            return _U(9) + x;\n        };\n        _F = function(x) {\n            return _R(9) + x;\n        };\n        _D = function(x) {\n            return _F(9) + x;\n        };\n        _L = function(x) {\n            return _D(9) + x;\n        };\n        _B = function(x) {\n            return _L(9) + x;\n        };\n        return [\n            // Centers\n            [\n                4,\n                13,\n                22,\n                31,\n                40,\n                49\n            ],\n            // Corners\n            [\n                [\n                    _U(9),\n                    _R(1),\n                    _F(3)\n                ],\n                [\n                    _U(7),\n                    _F(1),\n                    _L(3)\n                ],\n                [\n                    _U(1),\n                    _L(1),\n                    _B(3)\n                ],\n                [\n                    _U(3),\n                    _B(1),\n                    _R(3)\n                ],\n                [\n                    _D(3),\n                    _F(9),\n                    _R(7)\n                ],\n                [\n                    _D(1),\n                    _L(9),\n                    _F(7)\n                ],\n                [\n                    _D(7),\n                    _B(9),\n                    _L(7)\n                ],\n                [\n                    _D(9),\n                    _R(9),\n                    _B(7)\n                ]\n            ],\n            // Edges\n            [\n                [\n                    _U(6),\n                    _R(2)\n                ],\n                [\n                    _U(8),\n                    _F(2)\n                ],\n                [\n                    _U(4),\n                    _L(2)\n                ],\n                [\n                    _U(2),\n                    _B(2)\n                ],\n                [\n                    _D(6),\n                    _R(8)\n                ],\n                [\n                    _D(2),\n                    _F(8)\n                ],\n                [\n                    _D(4),\n                    _L(8)\n                ],\n                [\n                    _D(8),\n                    _B(8)\n                ],\n                [\n                    _F(6),\n                    _R(4)\n                ],\n                [\n                    _F(4),\n                    _L(6)\n                ],\n                [\n                    _B(6),\n                    _L(4)\n                ],\n                [\n                    _B(4),\n                    _R(6)\n                ]\n            ]\n        ];\n    }();\n    centerColor = [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"D\",\n        \"L\",\n        \"B\"\n    ];\n    cornerColor = [\n        [\n            \"U\",\n            \"R\",\n            \"F\"\n        ],\n        [\n            \"U\",\n            \"F\",\n            \"L\"\n        ],\n        [\n            \"U\",\n            \"L\",\n            \"B\"\n        ],\n        [\n            \"U\",\n            \"B\",\n            \"R\"\n        ],\n        [\n            \"D\",\n            \"F\",\n            \"R\"\n        ],\n        [\n            \"D\",\n            \"L\",\n            \"F\"\n        ],\n        [\n            \"D\",\n            \"B\",\n            \"L\"\n        ],\n        [\n            \"D\",\n            \"R\",\n            \"B\"\n        ]\n    ];\n    edgeColor = [\n        [\n            \"U\",\n            \"R\"\n        ],\n        [\n            \"U\",\n            \"F\"\n        ],\n        [\n            \"U\",\n            \"L\"\n        ],\n        [\n            \"U\",\n            \"B\"\n        ],\n        [\n            \"D\",\n            \"R\"\n        ],\n        [\n            \"D\",\n            \"F\"\n        ],\n        [\n            \"D\",\n            \"L\"\n        ],\n        [\n            \"D\",\n            \"B\"\n        ],\n        [\n            \"F\",\n            \"R\"\n        ],\n        [\n            \"F\",\n            \"L\"\n        ],\n        [\n            \"B\",\n            \"L\"\n        ],\n        [\n            \"B\",\n            \"R\"\n        ]\n    ];\n    Cube = (function() {\n        var faceNames, faceNums, parseAlg;\n        class Cube {\n            constructor(other){\n                var x;\n                if (other != null) this.init(other);\n                else this.identity();\n                // For moves to avoid allocating new objects each time\n                this.newCenter = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 5; x = ++k)results.push(0);\n                    return results;\n                }();\n                this.newCp = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 7; x = ++k)results.push(0);\n                    return results;\n                }();\n                this.newEp = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 11; x = ++k)results.push(0);\n                    return results;\n                }();\n                this.newCo = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 7; x = ++k)results.push(0);\n                    return results;\n                }();\n                this.newEo = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 11; x = ++k)results.push(0);\n                    return results;\n                }();\n            }\n            init(state) {\n                this.center = state.center.slice(0);\n                this.co = state.co.slice(0);\n                this.ep = state.ep.slice(0);\n                this.cp = state.cp.slice(0);\n                return this.eo = state.eo.slice(0);\n            }\n            identity() {\n                var x;\n                // Initialize to the identity cube\n                this.center = [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ];\n                this.cp = [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7\n                ];\n                this.co = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 7; x = ++k)results.push(0);\n                    return results;\n                }();\n                this.ep = [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8,\n                    9,\n                    10,\n                    11\n                ];\n                return this.eo = function() {\n                    var k, results;\n                    results = [];\n                    for(x = k = 0; k <= 11; x = ++k)results.push(0);\n                    return results;\n                }();\n            }\n            toJSON() {\n                return {\n                    center: this.center,\n                    cp: this.cp,\n                    co: this.co,\n                    ep: this.ep,\n                    eo: this.eo\n                };\n            }\n            asString() {\n                var corner, edge, i, k, l, m, n, o, ori, p, result;\n                result = [];\n                for(i = k = 0; k <= 5; i = ++k)result[9 * i + 4] = centerColor[this.center[i]];\n                for(i = l = 0; l <= 7; i = ++l){\n                    corner = this.cp[i];\n                    ori = this.co[i];\n                    for(n = m = 0; m <= 2; n = ++m)result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];\n                }\n                for(i = o = 0; o <= 11; i = ++o){\n                    edge = this.ep[i];\n                    ori = this.eo[i];\n                    for(n = p = 0; p <= 1; n = ++p)result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];\n                }\n                return result.join(\"\");\n            }\n            static fromString(str) {\n                var col1, col2, cube, i, j, k, l, m, o, ori, p, q, r, ref;\n                cube = new Cube;\n                for(i = k = 0; k <= 5; i = ++k){\n                    for(j = l = 0; l <= 5; j = ++l)if (str[9 * i + 4] === centerColor[j]) cube.center[i] = j;\n                }\n                for(i = m = 0; m <= 7; i = ++m){\n                    for(ori = o = 0; o <= 2; ori = ++o){\n                        if ((ref = str[cornerFacelet[i][ori]]) === \"U\" || ref === \"D\") break;\n                    }\n                    col1 = str[cornerFacelet[i][(ori + 1) % 3]];\n                    col2 = str[cornerFacelet[i][(ori + 2) % 3]];\n                    for(j = p = 0; p <= 7; j = ++p)if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {\n                        cube.cp[i] = j;\n                        cube.co[i] = ori % 3;\n                    }\n                }\n                for(i = q = 0; q <= 11; i = ++q)for(j = r = 0; r <= 11; j = ++r){\n                    if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {\n                        cube.ep[i] = j;\n                        cube.eo[i] = 0;\n                        break;\n                    }\n                    if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {\n                        cube.ep[i] = j;\n                        cube.eo[i] = 1;\n                        break;\n                    }\n                }\n                return cube;\n            }\n            clone() {\n                return new Cube(this.toJSON());\n            }\n            // A class method returning a new random cube\n            static random() {\n                return new Cube().randomize();\n            }\n            isSolved() {\n                var c, cent, clone, e, k, l, m;\n                clone = this.clone();\n                clone.move(clone.upright());\n                for(cent = k = 0; k <= 5; cent = ++k){\n                    if (clone.center[cent] !== cent) return false;\n                }\n                for(c = l = 0; l <= 7; c = ++l){\n                    if (clone.cp[c] !== c) return false;\n                    if (clone.co[c] !== 0) return false;\n                }\n                for(e = m = 0; m <= 11; e = ++m){\n                    if (clone.ep[e] !== e) return false;\n                    if (clone.eo[e] !== 0) return false;\n                }\n                return true;\n            }\n            // Multiply this Cube with another Cube, restricted to centers.\n            centerMultiply(other) {\n                var from, k, to;\n                for(to = k = 0; k <= 5; to = ++k){\n                    from = other.center[to];\n                    this.newCenter[to] = this.center[from];\n                }\n                [this.center, this.newCenter] = [\n                    this.newCenter,\n                    this.center\n                ];\n                return this;\n            }\n            // Multiply this Cube with another Cube, restricted to corners.\n            cornerMultiply(other) {\n                var from, k, to;\n                for(to = k = 0; k <= 7; to = ++k){\n                    from = other.cp[to];\n                    this.newCp[to] = this.cp[from];\n                    this.newCo[to] = (this.co[from] + other.co[to]) % 3;\n                }\n                [this.cp, this.newCp] = [\n                    this.newCp,\n                    this.cp\n                ];\n                [this.co, this.newCo] = [\n                    this.newCo,\n                    this.co\n                ];\n                return this;\n            }\n            // Multiply this Cube with another Cube, restricted to edges\n            edgeMultiply(other) {\n                var from, k, to;\n                for(to = k = 0; k <= 11; to = ++k){\n                    from = other.ep[to];\n                    this.newEp[to] = this.ep[from];\n                    this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;\n                }\n                [this.ep, this.newEp] = [\n                    this.newEp,\n                    this.ep\n                ];\n                [this.eo, this.newEo] = [\n                    this.newEo,\n                    this.eo\n                ];\n                return this;\n            }\n            // Multiply this cube with another Cube\n            multiply(other) {\n                this.centerMultiply(other);\n                this.cornerMultiply(other);\n                this.edgeMultiply(other);\n                return this;\n            }\n            move(arg) {\n                var face, k, l, len, move, power, ref, ref1, x;\n                ref = parseAlg(arg);\n                for(k = 0, len = ref.length; k < len; k++){\n                    move = ref[k];\n                    face = move / 3 | 0;\n                    power = move % 3;\n                    for(x = l = 0, ref1 = power; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l)this.multiply(Cube.moves[face]);\n                }\n                return this;\n            }\n            upright() {\n                var clone, i, j, k, l, result;\n                clone = this.clone();\n                result = [];\n                for(i = k = 0; k <= 5; i = ++k){\n                    if (clone.center[i] === F) break;\n                }\n                switch(i){\n                    case D:\n                        result.push(\"x\");\n                        break;\n                    case U:\n                        result.push(\"x'\");\n                        break;\n                    case B:\n                        result.push(\"x2\");\n                        break;\n                    case R:\n                        result.push(\"y\");\n                        break;\n                    case L:\n                        result.push(\"y'\");\n                }\n                if (result.length) clone.move(result[0]);\n                for(j = l = 0; l <= 5; j = ++l){\n                    if (clone.center[j] === U) break;\n                }\n                switch(j){\n                    case L:\n                        result.push(\"z\");\n                        break;\n                    case R:\n                        result.push(\"z'\");\n                        break;\n                    case D:\n                        result.push(\"z2\");\n                }\n                return result.join(\" \");\n            }\n            static inverse(arg) {\n                var face, k, len, move, power, result, str;\n                result = function() {\n                    var k, len, ref, results;\n                    ref = parseAlg(arg);\n                    results = [];\n                    for(k = 0, len = ref.length; k < len; k++){\n                        move = ref[k];\n                        face = move / 3 | 0;\n                        power = move % 3;\n                        results.push(face * 3 + -(power - 1) + 1);\n                    }\n                    return results;\n                }();\n                result.reverse();\n                if (typeof arg === \"string\") {\n                    str = \"\";\n                    for(k = 0, len = result.length; k < len; k++){\n                        move = result[k];\n                        face = move / 3 | 0;\n                        power = move % 3;\n                        str += faceNames[face];\n                        if (power === 1) str += \"2\";\n                        else if (power === 2) str += \"'\";\n                        str += \" \";\n                    }\n                    return str.substring(0, str.length - 1);\n                } else if (arg.length != null) return result;\n                else return result[0];\n            }\n        }\n        Cube.prototype.randomize = function() {\n            var arePermutationsValid, generateValidRandomOrientation, generateValidRandomPermutation, getNumSwaps, isOrientationValid, randint, randomizeOrientation, result, shuffle;\n            randint = function(min, max) {\n                return min + Math.floor(Math.random() * (max - min + 1));\n            };\n            // Fisher-Yates shuffle adapted from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n            shuffle = function(array) {\n                var currentIndex, randomIndex, temporaryValue;\n                currentIndex = array.length;\n                // While there remain elements to shuffle...\n                while(currentIndex !== 0){\n                    // Pick a remaining element...\n                    randomIndex = randint(0, currentIndex - 1);\n                    currentIndex -= 1;\n                    // And swap it with the current element.\n                    temporaryValue = array[currentIndex];\n                    [array[currentIndex], array[randomIndex]] = [\n                        array[randomIndex],\n                        array[currentIndex]\n                    ];\n                }\n            };\n            getNumSwaps = function(arr) {\n                var cur, cycleLength, i, k, numSwaps, ref, seen, x;\n                numSwaps = 0;\n                seen = function() {\n                    var k, ref, results;\n                    results = [];\n                    for(x = k = 0, ref = arr.length - 1; 0 <= ref ? k <= ref : k >= ref; x = 0 <= ref ? ++k : --k)results.push(false);\n                    return results;\n                }();\n                while(true){\n                    // We compute the cycle decomposition\n                    cur = -1;\n                    for(i = k = 0, ref = arr.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k)if (!seen[i]) {\n                        cur = i;\n                        break;\n                    }\n                    if (cur === -1) break;\n                    cycleLength = 0;\n                    while(!seen[cur]){\n                        seen[cur] = true;\n                        cycleLength++;\n                        cur = arr[cur];\n                    }\n                    // A cycle is equivalent to cycleLength + 1 swaps\n                    numSwaps += cycleLength + 1;\n                }\n                return numSwaps;\n            };\n            arePermutationsValid = function(cp, ep) {\n                var numSwaps;\n                numSwaps = getNumSwaps(ep) + getNumSwaps(cp);\n                return numSwaps % 2 === 0;\n            };\n            generateValidRandomPermutation = function(cp, ep) {\n                // Each shuffle only takes around 12 operations and there's a 50%\n                // chance of a valid permutation so it'll finish in very good time\n                shuffle(ep);\n                shuffle(cp);\n                while(!arePermutationsValid(cp, ep)){\n                    shuffle(ep);\n                    shuffle(cp);\n                }\n            };\n            randomizeOrientation = function(arr, numOrientations) {\n                var i, k, ori, ref;\n                ori = 0;\n                for(i = k = 0, ref = arr.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k)ori += arr[i] = randint(0, numOrientations - 1);\n            };\n            isOrientationValid = function(arr, numOrientations) {\n                return arr.reduce(function(a, b) {\n                    return a + b;\n                }) % numOrientations === 0;\n            };\n            generateValidRandomOrientation = function(co, eo) {\n                // There is a 1/2 and 1/3 probably respectively of each of these\n                // succeeding so the probability of them running 10 times before\n                // success is already only 1% and only gets exponentially lower\n                // and each generation is only in the 10s of operations which is nothing\n                randomizeOrientation(co, 3);\n                while(!isOrientationValid(co, 3))randomizeOrientation(co, 3);\n                randomizeOrientation(eo, 2);\n                while(!isOrientationValid(eo, 2))randomizeOrientation(eo, 2);\n            };\n            result = function() {\n                generateValidRandomPermutation(this.cp, this.ep);\n                generateValidRandomOrientation(this.co, this.eo);\n                return this;\n            };\n            return result;\n        }();\n        Cube.moves = [\n            {\n                // U\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    UBR,\n                    URF,\n                    UFL,\n                    ULB,\n                    DFR,\n                    DLF,\n                    DBL,\n                    DRB\n                ],\n                co: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                ep: [\n                    UB,\n                    UR,\n                    UF,\n                    UL,\n                    DR,\n                    DF,\n                    DL,\n                    DB,\n                    FR,\n                    FL,\n                    BL,\n                    BR\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            },\n            {\n                // R\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    DFR,\n                    UFL,\n                    ULB,\n                    URF,\n                    DRB,\n                    DLF,\n                    DBL,\n                    UBR\n                ],\n                co: [\n                    2,\n                    0,\n                    0,\n                    1,\n                    1,\n                    0,\n                    0,\n                    2\n                ],\n                ep: [\n                    FR,\n                    UF,\n                    UL,\n                    UB,\n                    BR,\n                    DF,\n                    DL,\n                    DB,\n                    DR,\n                    FL,\n                    BL,\n                    UR\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            },\n            {\n                // F\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    UFL,\n                    DLF,\n                    ULB,\n                    UBR,\n                    URF,\n                    DFR,\n                    DBL,\n                    DRB\n                ],\n                co: [\n                    1,\n                    2,\n                    0,\n                    0,\n                    2,\n                    1,\n                    0,\n                    0\n                ],\n                ep: [\n                    UR,\n                    FL,\n                    UL,\n                    UB,\n                    DR,\n                    FR,\n                    DL,\n                    DB,\n                    UF,\n                    DF,\n                    BL,\n                    BR\n                ],\n                eo: [\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    1,\n                    1,\n                    0,\n                    0\n                ]\n            },\n            {\n                // D\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    URF,\n                    UFL,\n                    ULB,\n                    UBR,\n                    DLF,\n                    DBL,\n                    DRB,\n                    DFR\n                ],\n                co: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                ep: [\n                    UR,\n                    UF,\n                    UL,\n                    UB,\n                    DF,\n                    DL,\n                    DB,\n                    DR,\n                    FR,\n                    FL,\n                    BL,\n                    BR\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            },\n            {\n                // L\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    URF,\n                    ULB,\n                    DBL,\n                    UBR,\n                    DFR,\n                    UFL,\n                    DLF,\n                    DRB\n                ],\n                co: [\n                    0,\n                    1,\n                    2,\n                    0,\n                    0,\n                    2,\n                    1,\n                    0\n                ],\n                ep: [\n                    UR,\n                    UF,\n                    BL,\n                    UB,\n                    DR,\n                    DF,\n                    FL,\n                    DB,\n                    FR,\n                    UL,\n                    DL,\n                    BR\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            },\n            {\n                // B\n                center: [\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                    5\n                ],\n                cp: [\n                    URF,\n                    UFL,\n                    UBR,\n                    DRB,\n                    DFR,\n                    DLF,\n                    ULB,\n                    DBL\n                ],\n                co: [\n                    0,\n                    0,\n                    1,\n                    2,\n                    0,\n                    0,\n                    2,\n                    1\n                ],\n                ep: [\n                    UR,\n                    UF,\n                    UL,\n                    BR,\n                    DR,\n                    DF,\n                    DL,\n                    BL,\n                    FR,\n                    FL,\n                    UB,\n                    DB\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    1,\n                    1\n                ]\n            },\n            {\n                // E\n                center: [\n                    U,\n                    F,\n                    L,\n                    D,\n                    B,\n                    R\n                ],\n                cp: [\n                    URF,\n                    UFL,\n                    ULB,\n                    UBR,\n                    DFR,\n                    DLF,\n                    DBL,\n                    DRB\n                ],\n                co: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                ep: [\n                    UR,\n                    UF,\n                    UL,\n                    UB,\n                    DR,\n                    DF,\n                    DL,\n                    DB,\n                    FL,\n                    BL,\n                    BR,\n                    FR\n                ],\n                eo: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1,\n                    1,\n                    1,\n                    1\n                ]\n            },\n            {\n                // M\n                center: [\n                    B,\n                    R,\n                    U,\n                    F,\n                    L,\n                    D\n                ],\n                cp: [\n                    URF,\n                    UFL,\n                    ULB,\n                    UBR,\n                    DFR,\n                    DLF,\n                    DBL,\n                    DRB\n                ],\n                co: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                ep: [\n                    UR,\n                    UB,\n                    UL,\n                    DB,\n                    DR,\n                    UF,\n                    DL,\n                    DF,\n                    FR,\n                    FL,\n                    BL,\n                    BR\n                ],\n                eo: [\n                    0,\n                    1,\n                    0,\n                    1,\n                    0,\n                    1,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            },\n            {\n                // S\n                center: [\n                    L,\n                    U,\n                    F,\n                    R,\n                    D,\n                    B\n                ],\n                cp: [\n                    URF,\n                    UFL,\n                    ULB,\n                    UBR,\n                    DFR,\n                    DLF,\n                    DBL,\n                    DRB\n                ],\n                co: [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                ep: [\n                    UL,\n                    UF,\n                    DL,\n                    UB,\n                    UR,\n                    DF,\n                    DR,\n                    DB,\n                    FR,\n                    FL,\n                    BL,\n                    BR\n                ],\n                eo: [\n                    1,\n                    0,\n                    1,\n                    0,\n                    1,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            }\n        ];\n        faceNums = {\n            U: 0,\n            R: 1,\n            F: 2,\n            D: 3,\n            L: 4,\n            B: 5,\n            E: 6,\n            M: 7,\n            S: 8,\n            x: 9,\n            y: 10,\n            z: 11,\n            u: 12,\n            r: 13,\n            f: 14,\n            d: 15,\n            l: 16,\n            b: 17\n        };\n        faceNames = {\n            0: \"U\",\n            1: \"R\",\n            2: \"F\",\n            3: \"D\",\n            4: \"L\",\n            5: \"B\",\n            6: \"E\",\n            7: \"M\",\n            8: \"S\",\n            9: \"x\",\n            10: \"y\",\n            11: \"z\",\n            12: \"u\",\n            13: \"r\",\n            14: \"f\",\n            15: \"d\",\n            16: \"l\",\n            17: \"b\"\n        };\n        parseAlg = function(arg) {\n            var k, len, move, part, power, ref, results;\n            if (typeof arg === \"string\") {\n                ref = arg.split(/\\s+/);\n                // String\n                results = [];\n                for(k = 0, len = ref.length; k < len; k++){\n                    part = ref[k];\n                    if (part.length === 0) continue;\n                    if (part.length > 2) throw new Error(`Invalid move: ${part}`);\n                    move = faceNums[part[0]];\n                    if (move === void 0) throw new Error(`Invalid move: ${part}`);\n                    if (part.length === 1) power = 0;\n                    else {\n                        if (part[1] === \"2\") power = 1;\n                        else if (part[1] === \"'\") power = 2;\n                        else throw new Error(`Invalid move: ${part}`);\n                    }\n                    results.push(move * 3 + power);\n                }\n                return results;\n            } else if (arg.length != null) // Already an array\n            return arg;\n            else // A single move\n            return [\n                arg\n            ];\n        };\n        // x\n        Cube.moves.push(new Cube().move(\"R M' L'\").toJSON());\n        // y\n        Cube.moves.push(new Cube().move(\"U E' D'\").toJSON());\n        // z\n        Cube.moves.push(new Cube().move(\"F S B'\").toJSON());\n        // u\n        Cube.moves.push(new Cube().move(\"U E'\").toJSON());\n        // r\n        Cube.moves.push(new Cube().move(\"R M'\").toJSON());\n        // f\n        Cube.moves.push(new Cube().move(\"F S\").toJSON());\n        // d\n        Cube.moves.push(new Cube().move(\"D E\").toJSON());\n        // l\n        Cube.moves.push(new Cube().move(\"L M\").toJSON());\n        // b\n        Cube.moves.push(new Cube().move(\"B S'\").toJSON());\n        return Cube;\n    }).call(this);\n    //# Globals\n    if (module !== null) module.exports = Cube;\n    else this.Cube = Cube;\n}).call(this);\n\n});\n\nvar $e46aab79b15c8453$exports = {};\n\n$e46aab79b15c8453$exports = (parcelRequire(\"aPTAb\"));\nvar $2ce18ebb622d0d6a$exports = {};\n\n(function() {\n    var B, BL, BR, Cnk, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, Include, L, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, faceNames, faceNums, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, rotateLeft, rotateRight, value, indexOf = [].indexOf;\n    Cube = this.Cube || (parcelRequire(\"aPTAb\"));\n    // Centers\n    [U, R, F, D, L, B] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5\n    ];\n    // Corners\n    [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7\n    ];\n    // Edges\n    [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11\n    ];\n    //# Helpers\n    // n choose k, i.e. the binomial coeffiecient\n    Cnk = function(n, k) {\n        var i, j, s;\n        if (n < k) return 0;\n        if (k > n / 2) k = n - k;\n        s = 1;\n        i = n;\n        j = 1;\n        while(i !== n - k){\n            s *= i;\n            s /= j;\n            i--;\n            j++;\n        }\n        return s;\n    };\n    // n!\n    factorial = function(n) {\n        var f, i, m, ref;\n        f = 1;\n        for(i = m = 2, ref = n; 2 <= ref ? m <= ref : m >= ref; i = 2 <= ref ? ++m : --m)f *= i;\n        return f;\n    };\n    // Maximum of two values\n    max = function(a, b) {\n        if (a > b) return a;\n        else return b;\n    };\n    // Rotate elements between l and r left by one place\n    rotateLeft = function(array, l, r) {\n        var i, m, ref, ref1, tmp;\n        tmp = array[l];\n        for(i = m = ref = l, ref1 = r - 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m)array[i] = array[i + 1];\n        return array[r] = tmp;\n    };\n    // Rotate elements between l and r right by one place\n    rotateRight = function(array, l, r) {\n        var i, m, ref, ref1, tmp;\n        tmp = array[r];\n        for(i = m = ref = r, ref1 = l + 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m)array[i] = array[i - 1];\n        return array[l] = tmp;\n    };\n    // Generate a function that computes permutation indices.\n    // The permutation index actually encodes two indices: Combination,\n    // i.e. positions of the cubies start..end (A) and their respective\n    // permutation (B). The maximum value for B is\n    //   maxB = (end - start + 1)!\n    // and the index is A * maxB + B\n    permutationIndex = function(context, start, end, fromEnd = false) {\n        var i, maxAll, maxB, maxOur, our, permName;\n        maxOur = end - start;\n        maxB = factorial(maxOur + 1);\n        if (context === \"corners\") {\n            maxAll = 7;\n            permName = \"cp\";\n        } else {\n            maxAll = 11;\n            permName = \"ep\";\n        }\n        our = function() {\n            var m, ref, results;\n            results = [];\n            for(i = m = 0, ref = maxOur; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m)results.push(0);\n            return results;\n        }();\n        return function(index) {\n            var a, b, c, j, k, m, o, p, perm, q, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;\n            if (index != null) {\n                for(i = m = 0, ref = maxOur; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m)// Reset our to [start..end]\n                our[i] = i + start;\n                b = index % maxB; // permutation\n                a = index / maxB | 0; // combination\n                // Invalidate all edges\n                perm = this[permName];\n                for(i = o = 0, ref1 = maxAll; 0 <= ref1 ? o <= ref1 : o >= ref1; i = 0 <= ref1 ? ++o : --o)perm[i] = -1;\n                // Generate permutation from index b\n                for(j = p = 1, ref2 = maxOur; 1 <= ref2 ? p <= ref2 : p >= ref2; j = 1 <= ref2 ? ++p : --p){\n                    k = b % (j + 1);\n                    b = b / (j + 1) | 0;\n                    // TODO: Implement rotateRightBy(our, 0, j, k)\n                    while(k > 0){\n                        rotateRight(our, 0, j);\n                        k--;\n                    }\n                }\n                // Generate combination and set our edges\n                x = maxOur;\n                if (fromEnd) for(j = q = 0, ref3 = maxAll; 0 <= ref3 ? q <= ref3 : q >= ref3; j = 0 <= ref3 ? ++q : --q){\n                    c = Cnk(maxAll - j, x + 1);\n                    if (a - c >= 0) {\n                        perm[j] = our[maxOur - x];\n                        a -= c;\n                        x--;\n                    }\n                }\n                else for(j = t = ref4 = maxAll; ref4 <= 0 ? t <= 0 : t >= 0; j = ref4 <= 0 ? ++t : --t){\n                    c = Cnk(j, x + 1);\n                    if (a - c >= 0) {\n                        perm[j] = our[x];\n                        a -= c;\n                        x--;\n                    }\n                }\n                return this;\n            } else {\n                perm = this[permName];\n                for(i = u = 0, ref5 = maxOur; 0 <= ref5 ? u <= ref5 : u >= ref5; i = 0 <= ref5 ? ++u : --u)our[i] = -1;\n                a = b = x = 0;\n                // Compute the index a < ((maxAll + 1) choose (maxOur + 1)) and\n                // the permutation\n                if (fromEnd) {\n                    for(j = w = ref6 = maxAll; ref6 <= 0 ? w <= 0 : w >= 0; j = ref6 <= 0 ? ++w : --w)if (start <= (ref7 = perm[j]) && ref7 <= end) {\n                        a += Cnk(maxAll - j, x + 1);\n                        our[maxOur - x] = perm[j];\n                        x++;\n                    }\n                } else {\n                    for(j = y = 0, ref8 = maxAll; 0 <= ref8 ? y <= ref8 : y >= ref8; j = 0 <= ref8 ? ++y : --y)if (start <= (ref9 = perm[j]) && ref9 <= end) {\n                        a += Cnk(j, x + 1);\n                        our[x] = perm[j];\n                        x++;\n                    }\n                }\n                // Compute the index b < (maxOur + 1)! for the permutation\n                for(j = z = ref10 = maxOur; ref10 <= 0 ? z <= 0 : z >= 0; j = ref10 <= 0 ? ++z : --z){\n                    k = 0;\n                    while(our[j] !== start + j){\n                        rotateLeft(our, 0, j);\n                        k++;\n                    }\n                    b = (j + 1) * b + k;\n                }\n                return a * maxB + b;\n            }\n        };\n    };\n    Include = {\n        // The twist of the 8 corners, 0 <= twist < 3^7. The orientation of\n        // the DRB corner is fully determined by the orientation of the other\n        // corners.\n        twist: function(twist) {\n            var i, m, o, ori, parity, v;\n            if (twist != null) {\n                parity = 0;\n                for(i = m = 6; m >= 0; i = --m){\n                    ori = twist % 3;\n                    twist = twist / 3 | 0;\n                    this.co[i] = ori;\n                    parity += ori;\n                }\n                this.co[7] = (3 - parity % 3) % 3;\n                return this;\n            } else {\n                v = 0;\n                for(i = o = 0; o <= 6; i = ++o)v = 3 * v + this.co[i];\n                return v;\n            }\n        },\n        // The flip of the 12 edges, 0 <= flip < 2^11. The orientation of the\n        // BR edge is fully determined by the orientation of the other edges.\n        flip: function(flip) {\n            var i, m, o, ori, parity, v;\n            if (flip != null) {\n                parity = 0;\n                for(i = m = 10; m >= 0; i = --m){\n                    ori = flip % 2;\n                    flip = flip / 2 | 0;\n                    this.eo[i] = ori;\n                    parity += ori;\n                }\n                this.eo[11] = (2 - parity % 2) % 2;\n                return this;\n            } else {\n                v = 0;\n                for(i = o = 0; o <= 10; i = ++o)v = 2 * v + this.eo[i];\n                return v;\n            }\n        },\n        // Parity of the corner permutation\n        cornerParity: function() {\n            var i, j, m, o, ref, ref1, ref2, ref3, s;\n            s = 0;\n            for(i = m = ref = DRB, ref1 = URF + 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m){\n                for(j = o = ref2 = i - 1, ref3 = URF; ref2 <= ref3 ? o <= ref3 : o >= ref3; j = ref2 <= ref3 ? ++o : --o)if (this.cp[j] > this.cp[i]) s++;\n            }\n            return s % 2;\n        },\n        // Parity of the edges permutation. Parity of corners and edges are\n        // the same if the cube is solvable.\n        edgeParity: function() {\n            var i, j, m, o, ref, ref1, ref2, ref3, s;\n            s = 0;\n            for(i = m = ref = BR, ref1 = UR + 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m){\n                for(j = o = ref2 = i - 1, ref3 = UR; ref2 <= ref3 ? o <= ref3 : o >= ref3; j = ref2 <= ref3 ? ++o : --o)if (this.ep[j] > this.ep[i]) s++;\n            }\n            return s % 2;\n        },\n        // Permutation of the six corners URF, UFL, ULB, UBR, DFR, DLF\n        URFtoDLF: permutationIndex(\"corners\", URF, DLF),\n        // Permutation of the three edges UR, UF, UL\n        URtoUL: permutationIndex(\"edges\", UR, UL),\n        // Permutation of the three edges UB, DR, DF\n        UBtoDF: permutationIndex(\"edges\", UB, DF),\n        // Permutation of the six edges UR, UF, UL, UB, DR, DF\n        URtoDF: permutationIndex(\"edges\", UR, DF),\n        // Permutation of the equator slice edges FR, FL, BL and BR\n        FRtoBR: permutationIndex(\"edges\", FR, BR, true)\n    };\n    for(key in Include){\n        value = Include[key];\n        Cube.prototype[key] = value;\n    }\n    computeMoveTable = function(context, coord, size) {\n        var apply, cube, i, inner, j, k, m, move, o, p, ref, results;\n        // Loop through all valid values for the coordinate, setting cube's\n        // state in each iteration. Then apply each of the 18 moves to the\n        // cube, and compute the resulting coordinate.\n        apply = context === \"corners\" ? \"cornerMultiply\" : \"edgeMultiply\";\n        cube = new Cube;\n        results = [];\n        for(i = m = 0, ref = size - 1; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m){\n            cube[coord](i);\n            inner = [];\n            for(j = o = 0; o <= 5; j = ++o){\n                move = Cube.moves[j];\n                for(k = p = 0; p <= 2; k = ++p){\n                    cube[apply](move);\n                    inner.push(cube[coord]());\n                }\n                // 4th face turn restores the cube\n                cube[apply](move);\n            }\n            results.push(inner);\n        }\n        return results;\n    };\n    // Because we only have the phase 2 URtoDF coordinates, we need to\n    // merge the URtoUL and UBtoDF coordinates to URtoDF in the beginning\n    // of phase 2.\n    mergeURtoDF = function() {\n        var a, b;\n        a = new Cube;\n        b = new Cube;\n        return function(URtoUL, UBtoDF) {\n            var i, m;\n            // Collisions can be found because unset are set to -1\n            a.URtoUL(URtoUL);\n            b.UBtoDF(UBtoDF);\n            for(i = m = 0; m <= 7; i = ++m)if (a.ep[i] !== -1) {\n                if (b.ep[i] !== -1) return -1; // collision\n                else b.ep[i] = a.ep[i];\n            }\n            return b.URtoDF();\n        };\n    }();\n    N_TWIST = 2187; // 3^7 corner orientations\n    N_FLIP = 2048; // 2^11 possible edge flips\n    N_PARITY = 2; // 2 possible parities\n    N_FRtoBR = 11880; // 12!/(12-4)! permutations of FR..BR edges\n    N_SLICE1 = 495; // (12 choose 4) possible positions of FR..BR edges\n    N_SLICE2 = 24; // 4! permutations of FR..BR edges in phase 2\n    N_URFtoDLF = 20160; // 8!/(8-6)! permutations of URF..DLF corners\n    // The URtoDF move table is only computed for phase 2 because the full\n    // table would have >650000 entries\n    N_URtoDF = 20160; // 8!/(8-6)! permutation of UR..DF edges in phase 2\n    N_URtoUL = 1320; // 12!/(12-3)! permutations of UR..UL edges\n    N_UBtoDF = 1320; // 12!/(12-3)! permutations of UB..DF edges\n    // The move table for parity is so small that it's included here\n    Cube.moveTables = {\n        parity: [\n            [\n                1,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ],\n            [\n                0,\n                1,\n                0,\n                0,\n                1,\n                0,\n                0,\n                1,\n                0,\n                0,\n                1,\n                0,\n                0,\n                1,\n                0,\n                0,\n                1,\n                0\n            ]\n        ],\n        twist: null,\n        flip: null,\n        FRtoBR: null,\n        URFtoDLF: null,\n        URtoDF: null,\n        URtoUL: null,\n        UBtoDF: null,\n        mergeURtoDF: null\n    };\n    // Other move tables are computed on the fly\n    moveTableParams = {\n        // name: [scope, size]\n        twist: [\n            \"corners\",\n            N_TWIST\n        ],\n        flip: [\n            \"edges\",\n            N_FLIP\n        ],\n        FRtoBR: [\n            \"edges\",\n            N_FRtoBR\n        ],\n        URFtoDLF: [\n            \"corners\",\n            N_URFtoDLF\n        ],\n        URtoDF: [\n            \"edges\",\n            N_URtoDF\n        ],\n        URtoUL: [\n            \"edges\",\n            N_URtoUL\n        ],\n        UBtoDF: [\n            \"edges\",\n            N_UBtoDF\n        ],\n        mergeURtoDF: []\n    };\n    Cube.computeMoveTables = function(...tables) {\n        var len, m, name, scope, size, tableName;\n        if (tables.length === 0) tables = function() {\n            var results;\n            results = [];\n            for(name in moveTableParams)results.push(name);\n            return results;\n        }();\n        for(m = 0, len = tables.length; m < len; m++){\n            tableName = tables[m];\n            if (this.moveTables[tableName] !== null) continue;\n            if (tableName === \"mergeURtoDF\") this.moveTables.mergeURtoDF = function() {\n                var UBtoDF, URtoUL, o, results;\n                results = [];\n                for(URtoUL = o = 0; o <= 335; URtoUL = ++o)results.push(function() {\n                    var p, results1;\n                    results1 = [];\n                    for(UBtoDF = p = 0; p <= 335; UBtoDF = ++p)results1.push(mergeURtoDF(URtoUL, UBtoDF));\n                    return results1;\n                }());\n                return results;\n            }();\n            else {\n                [scope, size] = moveTableParams[tableName];\n                this.moveTables[tableName] = computeMoveTable(scope, tableName, size);\n            }\n        }\n        return this;\n    };\n    // Phase 1: All moves are valid\n    allMoves1 = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17\n    ];\n    // The list of next valid phase 1 moves when the given face was turned\n    // in the last move\n    nextMoves1 = function() {\n        var face, lastFace, m, next, o, p, power, results;\n        results = [];\n        for(lastFace = m = 0; m <= 5; lastFace = ++m){\n            next = [];\n            // Don't allow commuting moves, e.g. U U'. Also make sure that\n            // opposite faces are always moved in the same order, i.e. allow\n            // U D but no D U. This avoids sequences like U D U'.\n            for(face = o = 0; o <= 5; face = ++o){\n                if (face !== lastFace && face !== lastFace - 3) // single, double or inverse move\n                for(power = p = 0; p <= 2; power = ++p)next.push(face * 3 + power);\n            }\n            results.push(next);\n        }\n        return results;\n    }();\n    // Phase 2: Double moves of all faces plus quarter moves of U and D\n    allMoves2 = [\n        0,\n        1,\n        2,\n        4,\n        7,\n        9,\n        10,\n        11,\n        13,\n        16\n    ];\n    nextMoves2 = function() {\n        var face, lastFace, len, m, next, o, p, power, powers, results;\n        results = [];\n        for(lastFace = m = 0; m <= 5; lastFace = ++m){\n            next = [];\n            for(face = o = 0; o <= 5; face = ++o){\n                if (!(face !== lastFace && face !== lastFace - 3)) continue;\n                // Allow all moves of U and D and double moves of others\n                powers = face === 0 || face === 3 ? [\n                    0,\n                    1,\n                    2\n                ] : [\n                    1\n                ];\n                for(p = 0, len = powers.length; p < len; p++){\n                    power = powers[p];\n                    next.push(face * 3 + power);\n                }\n            }\n            results.push(next);\n        }\n        return results;\n    }();\n    // 8 values are encoded in one number\n    pruning = function(table, index, value) {\n        var pos, shift, slot;\n        pos = index % 8;\n        slot = index >> 3;\n        shift = pos << 2;\n        if (value != null) {\n            // Set\n            table[slot] &= ~(0xF << shift);\n            table[slot] |= value << shift;\n            return value;\n        } else // Get\n        return (table[slot] & 0xF << shift) >>> shift;\n    };\n    computePruningTable = function(phase, size, currentCoords, nextIndex) {\n        var current, depth, done, index, len, m, move, moves, next, o, ref, table, x;\n        // Initialize all values to 0xF\n        table = function() {\n            var m, ref, results;\n            results = [];\n            for(x = m = 0, ref = Math.ceil(size / 8) - 1; 0 <= ref ? m <= ref : m >= ref; x = 0 <= ref ? ++m : --m)results.push(0xFFFFFFFF);\n            return results;\n        }();\n        if (phase === 1) moves = allMoves1;\n        else moves = allMoves2;\n        depth = 0;\n        pruning(table, 0, depth);\n        done = 1;\n        // In each iteration, take each state found in the previous depth and\n        // compute the next state. Stop when all states have been assigned a\n        // depth.\n        while(done !== size){\n            for(index = m = 0, ref = size - 1; 0 <= ref ? m <= ref : m >= ref; index = 0 <= ref ? ++m : --m){\n                if (!(pruning(table, index) === depth)) continue;\n                current = currentCoords(index);\n                for(o = 0, len = moves.length; o < len; o++){\n                    move = moves[o];\n                    next = nextIndex(current, move);\n                    if (pruning(table, next) === 0xF) {\n                        pruning(table, next, depth + 1);\n                        done++;\n                    }\n                }\n            }\n            depth++;\n        }\n        return table;\n    };\n    Cube.pruningTables = {\n        sliceTwist: null,\n        sliceFlip: null,\n        sliceURFtoDLFParity: null,\n        sliceURtoDFParity: null\n    };\n    pruningTableParams = {\n        // name: [phase, size, currentCoords, nextIndex]\n        sliceTwist: [\n            1,\n            N_SLICE1 * N_TWIST,\n            function(index) {\n                return [\n                    index % N_SLICE1,\n                    index / N_SLICE1 | 0\n                ];\n            },\n            function(current, move) {\n                var newSlice, newTwist, slice, twist;\n                [slice, twist] = current;\n                newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n                newTwist = Cube.moveTables.twist[twist][move];\n                return newTwist * N_SLICE1 + newSlice;\n            }\n        ],\n        sliceFlip: [\n            1,\n            N_SLICE1 * N_FLIP,\n            function(index) {\n                return [\n                    index % N_SLICE1,\n                    index / N_SLICE1 | 0\n                ];\n            },\n            function(current, move) {\n                var flip, newFlip, newSlice, slice;\n                [slice, flip] = current;\n                newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n                newFlip = Cube.moveTables.flip[flip][move];\n                return newFlip * N_SLICE1 + newSlice;\n            }\n        ],\n        sliceURFtoDLFParity: [\n            2,\n            N_SLICE2 * N_URFtoDLF * N_PARITY,\n            function(index) {\n                return [\n                    index % 2,\n                    (index / 2 | 0) % N_SLICE2,\n                    (index / 2 | 0) / N_SLICE2 | 0\n                ];\n            },\n            function(current, move) {\n                var URFtoDLF, newParity, newSlice, newURFtoDLF, parity, slice;\n                [parity, slice, URFtoDLF] = current;\n                newParity = Cube.moveTables.parity[parity][move];\n                newSlice = Cube.moveTables.FRtoBR[slice][move];\n                newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];\n                return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;\n            }\n        ],\n        sliceURtoDFParity: [\n            2,\n            N_SLICE2 * N_URtoDF * N_PARITY,\n            function(index) {\n                return [\n                    index % 2,\n                    (index / 2 | 0) % N_SLICE2,\n                    (index / 2 | 0) / N_SLICE2 | 0\n                ];\n            },\n            function(current, move) {\n                var URtoDF, newParity, newSlice, newURtoDF, parity, slice;\n                [parity, slice, URtoDF] = current;\n                newParity = Cube.moveTables.parity[parity][move];\n                newSlice = Cube.moveTables.FRtoBR[slice][move];\n                newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];\n                return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;\n            }\n        ]\n    };\n    Cube.computePruningTables = function(...tables) {\n        var len, m, name, params, tableName;\n        if (tables.length === 0) tables = function() {\n            var results;\n            results = [];\n            for(name in pruningTableParams)results.push(name);\n            return results;\n        }();\n        for(m = 0, len = tables.length; m < len; m++){\n            tableName = tables[m];\n            if (this.pruningTables[tableName] !== null) continue;\n            params = pruningTableParams[tableName];\n            this.pruningTables[tableName] = computePruningTable(...params);\n        }\n        return this;\n    };\n    Cube.initSolver = function() {\n        Cube.computeMoveTables();\n        return Cube.computePruningTables();\n    };\n    Cube.prototype.solveUpright = function(maxDepth = 22) {\n        var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;\n        // Names for all moves, i.e. U, U2, U', F, F2, ...\n        moveNames = function() {\n            var face, faceName, m, o, power, powerName, result;\n            faceName = [\n                \"U\",\n                \"R\",\n                \"F\",\n                \"D\",\n                \"L\",\n                \"B\"\n            ];\n            powerName = [\n                \"\",\n                \"2\",\n                \"'\"\n            ];\n            result = [];\n            for(face = m = 0; m <= 5; face = ++m)for(power = o = 0; o <= 2; power = ++o)result.push(faceName[face] + powerName[power]);\n            return result;\n        }();\n        State = class State {\n            constructor(cube){\n                this.parent = null;\n                this.lastMove = null;\n                this.depth = 0;\n                if (cube) this.init(cube);\n            }\n            init(cube) {\n                // Phase 1 coordinates\n                this.flip = cube.flip();\n                this.twist = cube.twist();\n                this.slice = cube.FRtoBR() / N_SLICE2 | 0;\n                // Phase 2 coordinates\n                this.parity = cube.cornerParity();\n                this.URFtoDLF = cube.URFtoDLF();\n                this.FRtoBR = cube.FRtoBR();\n                // These are later merged to URtoDF when phase 2 begins\n                this.URtoUL = cube.URtoUL();\n                this.UBtoDF = cube.UBtoDF();\n                return this;\n            }\n            solution() {\n                if (this.parent) return this.parent.solution() + moveNames[this.lastMove] + \" \";\n                else return \"\";\n            }\n            //# Helpers\n            move(table, index, move) {\n                return Cube.moveTables[table][index][move];\n            }\n            pruning(table, index) {\n                return pruning(Cube.pruningTables[table], index);\n            }\n            //# Phase 1\n            // Return the next valid phase 1 moves for this state\n            moves1() {\n                if (this.lastMove !== null) return nextMoves1[this.lastMove / 3 | 0];\n                else return allMoves1;\n            }\n            // Compute the minimum number of moves to the end of phase 1\n            minDist1() {\n                var d1, d2;\n                // The maximum number of moves to the end of phase 1 wrt. the\n                // combination flip and slice coordinates only\n                d1 = this.pruning(\"sliceFlip\", N_SLICE1 * this.flip + this.slice);\n                // The combination of twist and slice coordinates\n                d2 = this.pruning(\"sliceTwist\", N_SLICE1 * this.twist + this.slice);\n                // The true minimal distance is the maximum of these two\n                return max(d1, d2);\n            }\n            // Compute the next phase 1 state for the given move\n            next1(move) {\n                var next;\n                next = freeStates.pop();\n                next.parent = this;\n                next.lastMove = move;\n                next.depth = this.depth + 1;\n                next.flip = this.move(\"flip\", this.flip, move);\n                next.twist = this.move(\"twist\", this.twist, move);\n                next.slice = this.move(\"FRtoBR\", this.slice * 24, move) / 24 | 0;\n                return next;\n            }\n            //# Phase 2\n            // Return the next valid phase 2 moves for this state\n            moves2() {\n                if (this.lastMove !== null) return nextMoves2[this.lastMove / 3 | 0];\n                else return allMoves2;\n            }\n            // Compute the minimum number of moves to the solved cube\n            minDist2() {\n                var d1, d2, index1, index2;\n                index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;\n                d1 = this.pruning(\"sliceURtoDFParity\", index1);\n                index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;\n                d2 = this.pruning(\"sliceURFtoDLFParity\", index2);\n                return max(d1, d2);\n            }\n            // Initialize phase 2 coordinates\n            init2(top = true) {\n                if (this.parent === null) return;\n                // For other states, the phase 2 state is computed based on\n                // parent's state.\n                // Already assigned for the initial state\n                this.parent.init2(false);\n                this.URFtoDLF = this.move(\"URFtoDLF\", this.parent.URFtoDLF, this.lastMove);\n                this.FRtoBR = this.move(\"FRtoBR\", this.parent.FRtoBR, this.lastMove);\n                this.parity = this.move(\"parity\", this.parent.parity, this.lastMove);\n                this.URtoUL = this.move(\"URtoUL\", this.parent.URtoUL, this.lastMove);\n                this.UBtoDF = this.move(\"UBtoDF\", this.parent.UBtoDF, this.lastMove);\n                if (top) // This is the initial phase 2 state. Get the URtoDF coordinate\n                // by merging URtoUL and UBtoDF\n                return this.URtoDF = this.move(\"mergeURtoDF\", this.URtoUL, this.UBtoDF);\n            }\n            // Compute the next phase 2 state for the given move\n            next2(move) {\n                var next;\n                next = freeStates.pop();\n                next.parent = this;\n                next.lastMove = move;\n                next.depth = this.depth + 1;\n                next.URFtoDLF = this.move(\"URFtoDLF\", this.URFtoDLF, move);\n                next.FRtoBR = this.move(\"FRtoBR\", this.FRtoBR, move);\n                next.parity = this.move(\"parity\", this.parity, move);\n                next.URtoDF = this.move(\"URtoDF\", this.URtoDF, move);\n                return next;\n            }\n        };\n        solution = null;\n        phase1search = function(state) {\n            var depth, m, ref, results;\n            depth = 0;\n            results = [];\n            for(depth = m = 1, ref = maxDepth; 1 <= ref ? m <= ref : m >= ref; depth = 1 <= ref ? ++m : --m){\n                phase1(state, depth);\n                if (solution !== null) break;\n                results.push(depth++);\n            }\n            return results;\n        };\n        phase1 = function(state, depth) {\n            var len, m, move, next, ref, ref1, results;\n            if (depth === 0) {\n                if (state.minDist1() === 0) {\n                    // Make sure we don't start phase 2 with a phase 2 move as the\n                    // last move in phase 1, because phase 2 would then repeat the\n                    // same move.\n                    if (state.lastMove === null || (ref = state.lastMove, indexOf.call(allMoves2, ref) < 0)) return phase2search(state);\n                }\n            } else if (depth > 0) {\n                if (state.minDist1() <= depth) {\n                    ref1 = state.moves1();\n                    results = [];\n                    for(m = 0, len = ref1.length; m < len; m++){\n                        move = ref1[m];\n                        next = state.next1(move);\n                        phase1(next, depth - 1);\n                        freeStates.push(next);\n                        if (solution !== null) break;\n                        else results.push(void 0);\n                    }\n                    return results;\n                }\n            }\n        };\n        phase2search = function(state) {\n            var depth, m, ref, results;\n            // Initialize phase 2 coordinates\n            state.init2();\n            results = [];\n            for(depth = m = 1, ref = maxDepth - state.depth; 1 <= ref ? m <= ref : m >= ref; depth = 1 <= ref ? ++m : --m){\n                phase2(state, depth);\n                if (solution !== null) break;\n                results.push(depth++);\n            }\n            return results;\n        };\n        phase2 = function(state, depth) {\n            var len, m, move, next, ref, results;\n            if (depth === 0) {\n                if (state.minDist2() === 0) return solution = state.solution();\n            } else if (depth > 0) {\n                if (state.minDist2() <= depth) {\n                    ref = state.moves2();\n                    results = [];\n                    for(m = 0, len = ref.length; m < len; m++){\n                        move = ref[m];\n                        next = state.next2(move);\n                        phase2(next, depth - 1);\n                        freeStates.push(next);\n                        if (solution !== null) break;\n                        else results.push(void 0);\n                    }\n                    return results;\n                }\n            }\n        };\n        freeStates = function() {\n            var m, ref, results;\n            results = [];\n            for(x = m = 0, ref = maxDepth + 1; 0 <= ref ? m <= ref : m >= ref; x = 0 <= ref ? ++m : --m)results.push(new State);\n            return results;\n        }();\n        state = freeStates.pop().init(this);\n        phase1search(state);\n        freeStates.push(state);\n        // Trim the trailing space\n        if (solution.length > 0) solution = solution.substring(0, solution.length - 1);\n        return solution;\n    };\n    faceNums = {\n        U: 0,\n        R: 1,\n        F: 2,\n        D: 3,\n        L: 4,\n        B: 5\n    };\n    faceNames = {\n        0: \"U\",\n        1: \"R\",\n        2: \"F\",\n        3: \"D\",\n        4: \"L\",\n        5: \"B\"\n    };\n    Cube.prototype.solve = function(maxDepth = 22) {\n        var clone, len, m, move, ref, rotation, solution, upright, uprightSolution;\n        clone = this.clone();\n        upright = clone.upright();\n        clone.move(upright);\n        rotation = new Cube().move(upright).center;\n        uprightSolution = clone.solveUpright(maxDepth);\n        solution = [];\n        ref = uprightSolution.split(\" \");\n        for(m = 0, len = ref.length; m < len; m++){\n            move = ref[m];\n            solution.push(faceNames[rotation[faceNums[move[0]]]]);\n            if (move.length > 1) solution[solution.length - 1] += move[1];\n        }\n        return solution.join(\" \");\n    };\n    Cube.scramble = function() {\n        return Cube.inverse(Cube.random().solve());\n    };\n}).call($2ce18ebb622d0d6a$exports);\n\n\n\n\nasync function $9495dc782b1de45f$var$init() {\n    (0, (/*@__PURE__*/$parcel$interopDefault($e46aab79b15c8453$exports))).initSolver();\n    document.querySelector(\"#status\").textContent = \"Ready\";\n}\n$9495dc782b1de45f$var$init();\n\n\n//# sourceMappingURL=index.e65b56a2.js.map\n","(function() {\n  // Centers\n  var B, BL, BR, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, L, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, centerColor, centerFacelet, cornerColor, cornerFacelet, edgeColor, edgeFacelet;\n\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  [centerFacelet, cornerFacelet, edgeFacelet] = (function() {\n    var _B, _D, _F, _L, _R, _U;\n    _U = function(x) {\n      return x - 1;\n    };\n    _R = function(x) {\n      return _U(9) + x;\n    };\n    _F = function(x) {\n      return _R(9) + x;\n    };\n    _D = function(x) {\n      return _F(9) + x;\n    };\n    _L = function(x) {\n      return _D(9) + x;\n    };\n    _B = function(x) {\n      return _L(9) + x;\n    };\n    return [\n      // Centers\n      [4,\n      13,\n      22,\n      31,\n      40,\n      49],\n      // Corners\n      [[_U(9),\n      _R(1),\n      _F(3)],\n      [_U(7),\n      _F(1),\n      _L(3)],\n      [_U(1),\n      _L(1),\n      _B(3)],\n      [_U(3),\n      _B(1),\n      _R(3)],\n      [_D(3),\n      _F(9),\n      _R(7)],\n      [_D(1),\n      _L(9),\n      _F(7)],\n      [_D(7),\n      _B(9),\n      _L(7)],\n      [_D(9),\n      _R(9),\n      _B(7)]],\n      // Edges\n      [[_U(6),\n      _R(2)],\n      [_U(8),\n      _F(2)],\n      [_U(4),\n      _L(2)],\n      [_U(2),\n      _B(2)],\n      [_D(6),\n      _R(8)],\n      [_D(2),\n      _F(8)],\n      [_D(4),\n      _L(8)],\n      [_D(8),\n      _B(8)],\n      [_F(6),\n      _R(4)],\n      [_F(4),\n      _L(6)],\n      [_B(6),\n      _L(4)],\n      [_B(4),\n      _R(6)]]\n    ];\n  })();\n\n  centerColor = ['U', 'R', 'F', 'D', 'L', 'B'];\n\n  cornerColor = [['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'], ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']];\n\n  edgeColor = [['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'], ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'], ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']];\n\n  Cube = (function() {\n    var faceNames, faceNums, parseAlg;\n\n    class Cube {\n      constructor(other) {\n        var x;\n        if (other != null) {\n          this.init(other);\n        } else {\n          this.identity();\n        }\n        // For moves to avoid allocating new objects each time\n        this.newCenter = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 5; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      init(state) {\n        this.center = state.center.slice(0);\n        this.co = state.co.slice(0);\n        this.ep = state.ep.slice(0);\n        this.cp = state.cp.slice(0);\n        return this.eo = state.eo.slice(0);\n      }\n\n      identity() {\n        var x;\n        // Initialize to the identity cube\n        this.center = [0, 1, 2, 3, 4, 5];\n        this.cp = [0, 1, 2, 3, 4, 5, 6, 7];\n        this.co = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n        return this.eo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      toJSON() {\n        return {\n          center: this.center,\n          cp: this.cp,\n          co: this.co,\n          ep: this.ep,\n          eo: this.eo\n        };\n      }\n\n      asString() {\n        var corner, edge, i, k, l, m, n, o, ori, p, result;\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          result[9 * i + 4] = centerColor[this.center[i]];\n        }\n        for (i = l = 0; l <= 7; i = ++l) {\n          corner = this.cp[i];\n          ori = this.co[i];\n          for (n = m = 0; m <= 2; n = ++m) {\n            result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];\n          }\n        }\n        for (i = o = 0; o <= 11; i = ++o) {\n          edge = this.ep[i];\n          ori = this.eo[i];\n          for (n = p = 0; p <= 1; n = ++p) {\n            result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];\n          }\n        }\n        return result.join('');\n      }\n\n      static fromString(str) {\n        var col1, col2, cube, i, j, k, l, m, o, ori, p, q, r, ref;\n        cube = new Cube;\n        for (i = k = 0; k <= 5; i = ++k) {\n          for (j = l = 0; l <= 5; j = ++l) {\n            if (str[9 * i + 4] === centerColor[j]) {\n              cube.center[i] = j;\n            }\n          }\n        }\n        for (i = m = 0; m <= 7; i = ++m) {\n          for (ori = o = 0; o <= 2; ori = ++o) {\n            if ((ref = str[cornerFacelet[i][ori]]) === 'U' || ref === 'D') {\n              break;\n            }\n          }\n          col1 = str[cornerFacelet[i][(ori + 1) % 3]];\n          col2 = str[cornerFacelet[i][(ori + 2) % 3]];\n          for (j = p = 0; p <= 7; j = ++p) {\n            if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {\n              cube.cp[i] = j;\n              cube.co[i] = ori % 3;\n            }\n          }\n        }\n        for (i = q = 0; q <= 11; i = ++q) {\n          for (j = r = 0; r <= 11; j = ++r) {\n            if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 0;\n              break;\n            }\n            if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 1;\n              break;\n            }\n          }\n        }\n        return cube;\n      }\n\n      clone() {\n        return new Cube(this.toJSON());\n      }\n\n      // A class method returning a new random cube\n      static random() {\n        return new Cube().randomize();\n      }\n\n      isSolved() {\n        var c, cent, clone, e, k, l, m;\n        clone = this.clone();\n        clone.move(clone.upright());\n        for (cent = k = 0; k <= 5; cent = ++k) {\n          if (clone.center[cent] !== cent) {\n            return false;\n          }\n        }\n        for (c = l = 0; l <= 7; c = ++l) {\n          if (clone.cp[c] !== c) {\n            return false;\n          }\n          if (clone.co[c] !== 0) {\n            return false;\n          }\n        }\n        for (e = m = 0; m <= 11; e = ++m) {\n          if (clone.ep[e] !== e) {\n            return false;\n          }\n          if (clone.eo[e] !== 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // Multiply this Cube with another Cube, restricted to centers.\n      centerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 5; to = ++k) {\n          from = other.center[to];\n          this.newCenter[to] = this.center[from];\n        }\n        [this.center, this.newCenter] = [this.newCenter, this.center];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to corners.\n      cornerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 7; to = ++k) {\n          from = other.cp[to];\n          this.newCp[to] = this.cp[from];\n          this.newCo[to] = (this.co[from] + other.co[to]) % 3;\n        }\n        [this.cp, this.newCp] = [this.newCp, this.cp];\n        [this.co, this.newCo] = [this.newCo, this.co];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to edges\n      edgeMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 11; to = ++k) {\n          from = other.ep[to];\n          this.newEp[to] = this.ep[from];\n          this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;\n        }\n        [this.ep, this.newEp] = [this.newEp, this.ep];\n        [this.eo, this.newEo] = [this.newEo, this.eo];\n        return this;\n      }\n\n      // Multiply this cube with another Cube\n      multiply(other) {\n        this.centerMultiply(other);\n        this.cornerMultiply(other);\n        this.edgeMultiply(other);\n        return this;\n      }\n\n      move(arg) {\n        var face, k, l, len, move, power, ref, ref1, x;\n        ref = parseAlg(arg);\n        for (k = 0, len = ref.length; k < len; k++) {\n          move = ref[k];\n          face = move / 3 | 0;\n          power = move % 3;\n          for (x = l = 0, ref1 = power; (0 <= ref1 ? l <= ref1 : l >= ref1); x = 0 <= ref1 ? ++l : --l) {\n            this.multiply(Cube.moves[face]);\n          }\n        }\n        return this;\n      }\n\n      upright() {\n        var clone, i, j, k, l, result;\n        clone = this.clone();\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          if (clone.center[i] === F) {\n            break;\n          }\n        }\n        switch (i) {\n          case D:\n            result.push(\"x\");\n            break;\n          case U:\n            result.push(\"x'\");\n            break;\n          case B:\n            result.push(\"x2\");\n            break;\n          case R:\n            result.push(\"y\");\n            break;\n          case L:\n            result.push(\"y'\");\n        }\n        if (result.length) {\n          clone.move(result[0]);\n        }\n        for (j = l = 0; l <= 5; j = ++l) {\n          if (clone.center[j] === U) {\n            break;\n          }\n        }\n        switch (j) {\n          case L:\n            result.push(\"z\");\n            break;\n          case R:\n            result.push(\"z'\");\n            break;\n          case D:\n            result.push(\"z2\");\n        }\n        return result.join(' ');\n      }\n\n      static inverse(arg) {\n        var face, k, len, move, power, result, str;\n        result = (function() {\n          var k, len, ref, results;\n          ref = parseAlg(arg);\n          results = [];\n          for (k = 0, len = ref.length; k < len; k++) {\n            move = ref[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            results.push(face * 3 + -(power - 1) + 1);\n          }\n          return results;\n        })();\n        result.reverse();\n        if (typeof arg === 'string') {\n          str = '';\n          for (k = 0, len = result.length; k < len; k++) {\n            move = result[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            str += faceNames[face];\n            if (power === 1) {\n              str += '2';\n            } else if (power === 2) {\n              str += \"'\";\n            }\n            str += ' ';\n          }\n          return str.substring(0, str.length - 1);\n        } else if (arg.length != null) {\n          return result;\n        } else {\n          return result[0];\n        }\n      }\n\n    };\n\n    Cube.prototype.randomize = (function() {\n      var arePermutationsValid, generateValidRandomOrientation, generateValidRandomPermutation, getNumSwaps, isOrientationValid, randint, randomizeOrientation, result, shuffle;\n      randint = function(min, max) {\n        return min + Math.floor(Math.random() * (max - min + 1));\n      };\n      // Fisher-Yates shuffle adapted from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n      shuffle = function(array) {\n        var currentIndex, randomIndex, temporaryValue;\n        currentIndex = array.length;\n        // While there remain elements to shuffle...\n        while (currentIndex !== 0) {\n          // Pick a remaining element...\n          randomIndex = randint(0, currentIndex - 1);\n          currentIndex -= 1;\n          // And swap it with the current element.\n          temporaryValue = array[currentIndex];\n          [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n        }\n      };\n      getNumSwaps = function(arr) {\n        var cur, cycleLength, i, k, numSwaps, ref, seen, x;\n        numSwaps = 0;\n        seen = (function() {\n          var k, ref, results;\n          results = [];\n          for (x = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); x = 0 <= ref ? ++k : --k) {\n            results.push(false);\n          }\n          return results;\n        })();\n        while (true) {\n          // We compute the cycle decomposition\n          cur = -1;\n          for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n            if (!seen[i]) {\n              cur = i;\n              break;\n            }\n          }\n          if (cur === -1) {\n            break;\n          }\n          cycleLength = 0;\n          while (!seen[cur]) {\n            seen[cur] = true;\n            cycleLength++;\n            cur = arr[cur];\n          }\n          // A cycle is equivalent to cycleLength + 1 swaps\n          numSwaps += cycleLength + 1;\n        }\n        return numSwaps;\n      };\n      arePermutationsValid = function(cp, ep) {\n        var numSwaps;\n        numSwaps = getNumSwaps(ep) + getNumSwaps(cp);\n        return numSwaps % 2 === 0;\n      };\n      generateValidRandomPermutation = function(cp, ep) {\n        // Each shuffle only takes around 12 operations and there's a 50%\n        // chance of a valid permutation so it'll finish in very good time\n        shuffle(ep);\n        shuffle(cp);\n        while (!arePermutationsValid(cp, ep)) {\n          shuffle(ep);\n          shuffle(cp);\n        }\n      };\n      randomizeOrientation = function(arr, numOrientations) {\n        var i, k, ori, ref;\n        ori = 0;\n        for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n          ori += (arr[i] = randint(0, numOrientations - 1));\n        }\n      };\n      isOrientationValid = function(arr, numOrientations) {\n        return arr.reduce(function(a, b) {\n          return a + b;\n        }) % numOrientations === 0;\n      };\n      generateValidRandomOrientation = function(co, eo) {\n        // There is a 1/2 and 1/3 probably respectively of each of these\n        // succeeding so the probability of them running 10 times before\n        // success is already only 1% and only gets exponentially lower\n        // and each generation is only in the 10s of operations which is nothing\n        randomizeOrientation(co, 3);\n        while (!isOrientationValid(co, 3)) {\n          randomizeOrientation(co, 3);\n        }\n        randomizeOrientation(eo, 2);\n        while (!isOrientationValid(eo, 2)) {\n          randomizeOrientation(eo, 2);\n        }\n      };\n      result = function() {\n        generateValidRandomPermutation(this.cp, this.ep);\n        generateValidRandomOrientation(this.co, this.eo);\n        return this;\n      };\n      return result;\n    })();\n\n    Cube.moves = [\n      {\n        // U\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UBR,\n      URF,\n      UFL,\n      ULB,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UB,\n      UR,\n      UF,\n      UL,\n      DR,\n      DF,\n      DL,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // R\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [DFR,\n      UFL,\n      ULB,\n      URF,\n      DRB,\n      DLF,\n      DBL,\n      UBR],\n        co: [2,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0,\n      2],\n        ep: [FR,\n      UF,\n      UL,\n      UB,\n      BR,\n      DF,\n      DL,\n      DB,\n      DR,\n      FL,\n      BL,\n      UR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // F\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UFL,\n      DLF,\n      ULB,\n      UBR,\n      URF,\n      DFR,\n      DBL,\n      DRB],\n        co: [1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0,\n      0],\n        ep: [UR,\n      FL,\n      UL,\n      UB,\n      DR,\n      FR,\n      DL,\n      DB,\n      UF,\n      DF,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0]\n      },\n      {\n        // D\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DLF,\n      DBL,\n      DRB,\n      DFR],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DF,\n      DL,\n      DB,\n      DR,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // L\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      ULB,\n      DBL,\n      UBR,\n      DFR,\n      UFL,\n      DLF,\n      DRB],\n        co: [0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0],\n        ep: [UR,\n      UF,\n      BL,\n      UB,\n      DR,\n      DF,\n      FL,\n      DB,\n      FR,\n      UL,\n      DL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // B\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      UBR,\n      DRB,\n      DFR,\n      DLF,\n      ULB,\n      DBL],\n        co: [0,\n      0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1],\n        ep: [UR,\n      UF,\n      UL,\n      BR,\n      DR,\n      DF,\n      DL,\n      BL,\n      FR,\n      FL,\n      UB,\n      DB],\n        eo: [0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1]\n      },\n      {\n        // E\n        center: [U,\n      F,\n      L,\n      D,\n      B,\n      R],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DR,\n      DF,\n      DL,\n      DB,\n      FL,\n      BL,\n      BR,\n      FR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      1,\n      1]\n      },\n      {\n        // M\n        center: [B,\n      R,\n      U,\n      F,\n      L,\n      D],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UB,\n      UL,\n      DB,\n      DR,\n      UF,\n      DL,\n      DF,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // S\n        center: [L,\n      U,\n      F,\n      R,\n      D,\n      B],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UL,\n      UF,\n      DL,\n      UB,\n      UR,\n      DF,\n      DR,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0]\n      }\n    ];\n\n    faceNums = {\n      U: 0,\n      R: 1,\n      F: 2,\n      D: 3,\n      L: 4,\n      B: 5,\n      E: 6,\n      M: 7,\n      S: 8,\n      x: 9,\n      y: 10,\n      z: 11,\n      u: 12,\n      r: 13,\n      f: 14,\n      d: 15,\n      l: 16,\n      b: 17\n    };\n\n    faceNames = {\n      0: 'U',\n      1: 'R',\n      2: 'F',\n      3: 'D',\n      4: 'L',\n      5: 'B',\n      6: 'E',\n      7: 'M',\n      8: 'S',\n      9: 'x',\n      10: 'y',\n      11: 'z',\n      12: 'u',\n      13: 'r',\n      14: 'f',\n      15: 'd',\n      16: 'l',\n      17: 'b'\n    };\n\n    parseAlg = function(arg) {\n      var k, len, move, part, power, ref, results;\n      if (typeof arg === 'string') {\n        ref = arg.split(/\\s+/);\n        // String\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          if (part.length === 0) {\n            // First and last can be empty\n            continue;\n          }\n          if (part.length > 2) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          move = faceNums[part[0]];\n          if (move === void 0) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          if (part.length === 1) {\n            power = 0;\n          } else {\n            if (part[1] === '2') {\n              power = 1;\n            } else if (part[1] === \"'\") {\n              power = 2;\n            } else {\n              throw new Error(`Invalid move: ${part}`);\n            }\n          }\n          results.push(move * 3 + power);\n        }\n        return results;\n      } else if (arg.length != null) {\n        // Already an array\n        return arg;\n      } else {\n        // A single move\n        return [arg];\n      }\n    };\n\n    // x\n    Cube.moves.push(new Cube().move(\"R M' L'\").toJSON());\n\n    // y\n    Cube.moves.push(new Cube().move(\"U E' D'\").toJSON());\n\n    // z\n    Cube.moves.push(new Cube().move(\"F S B'\").toJSON());\n\n    // u\n    Cube.moves.push(new Cube().move(\"U E'\").toJSON());\n\n    // r\n    Cube.moves.push(new Cube().move(\"R M'\").toJSON());\n\n    // f\n    Cube.moves.push(new Cube().move(\"F S\").toJSON());\n\n    // d\n    Cube.moves.push(new Cube().move(\"D E\").toJSON());\n\n    // l\n    Cube.moves.push(new Cube().move(\"L M\").toJSON());\n\n    // b\n    Cube.moves.push(new Cube().move(\"B S'\").toJSON());\n\n    return Cube;\n\n  }).call(this);\n\n  //# Globals\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = Cube;\n  } else {\n    this.Cube = Cube;\n  }\n\n}).call(this);\n","import Cube from \"cubejs\";\n\nasync function init() {\n  Cube.initSolver();\n  document.querySelector(\"#status\").textContent = \"Ready\";\n}\n\ninit();\n","module.exports = require('./lib/cube');\nrequire('./lib/solve');\n","(function() {\n  var B, BL, BR, Cnk, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, Include, L, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, faceNames, faceNums, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, rotateLeft, rotateRight, value,\n    indexOf = [].indexOf;\n\n  Cube = this.Cube || require('./cube');\n\n  // Centers\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  //# Helpers\n\n  // n choose k, i.e. the binomial coeffiecient\n  Cnk = function(n, k) {\n    var i, j, s;\n    if (n < k) {\n      return 0;\n    }\n    if (k > n / 2) {\n      k = n - k;\n    }\n    s = 1;\n    i = n;\n    j = 1;\n    while (i !== n - k) {\n      s *= i;\n      s /= j;\n      i--;\n      j++;\n    }\n    return s;\n  };\n\n  // n!\n  factorial = function(n) {\n    var f, i, m, ref;\n    f = 1;\n    for (i = m = 2, ref = n; (2 <= ref ? m <= ref : m >= ref); i = 2 <= ref ? ++m : --m) {\n      f *= i;\n    }\n    return f;\n  };\n\n  // Maximum of two values\n  max = function(a, b) {\n    if (a > b) {\n      return a;\n    } else {\n      return b;\n    }\n  };\n\n  // Rotate elements between l and r left by one place\n  rotateLeft = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[l];\n    for (i = m = ref = l, ref1 = r - 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i + 1];\n    }\n    return array[r] = tmp;\n  };\n\n  // Rotate elements between l and r right by one place\n  rotateRight = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[r];\n    for (i = m = ref = r, ref1 = l + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i - 1];\n    }\n    return array[l] = tmp;\n  };\n\n  // Generate a function that computes permutation indices.\n\n  // The permutation index actually encodes two indices: Combination,\n  // i.e. positions of the cubies start..end (A) and their respective\n  // permutation (B). The maximum value for B is\n\n  //   maxB = (end - start + 1)!\n\n  // and the index is A * maxB + B\n  permutationIndex = function(context, start, end, fromEnd = false) {\n    var i, maxAll, maxB, maxOur, our, permName;\n    maxOur = end - start;\n    maxB = factorial(maxOur + 1);\n    if (context === 'corners') {\n      maxAll = 7;\n      permName = 'cp';\n    } else {\n      maxAll = 11;\n      permName = 'ep';\n    }\n    our = (function() {\n      var m, ref, results;\n      results = [];\n      for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n        results.push(0);\n      }\n      return results;\n    })();\n    return function(index) {\n      var a, b, c, j, k, m, o, p, perm, q, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;\n      if (index != null) {\n        for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n          // Reset our to [start..end]\n          our[i] = i + start;\n        }\n        b = index % maxB; // permutation\n        a = index / maxB | 0; // combination\n        \n        // Invalidate all edges\n        perm = this[permName];\n        for (i = o = 0, ref1 = maxAll; (0 <= ref1 ? o <= ref1 : o >= ref1); i = 0 <= ref1 ? ++o : --o) {\n          perm[i] = -1;\n        }\n// Generate permutation from index b\n        for (j = p = 1, ref2 = maxOur; (1 <= ref2 ? p <= ref2 : p >= ref2); j = 1 <= ref2 ? ++p : --p) {\n          k = b % (j + 1);\n          b = b / (j + 1) | 0;\n          // TODO: Implement rotateRightBy(our, 0, j, k)\n          while (k > 0) {\n            rotateRight(our, 0, j);\n            k--;\n          }\n        }\n        // Generate combination and set our edges\n        x = maxOur;\n        if (fromEnd) {\n          for (j = q = 0, ref3 = maxAll; (0 <= ref3 ? q <= ref3 : q >= ref3); j = 0 <= ref3 ? ++q : --q) {\n            c = Cnk(maxAll - j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[maxOur - x];\n              a -= c;\n              x--;\n            }\n          }\n        } else {\n          for (j = t = ref4 = maxAll; (ref4 <= 0 ? t <= 0 : t >= 0); j = ref4 <= 0 ? ++t : --t) {\n            c = Cnk(j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[x];\n              a -= c;\n              x--;\n            }\n          }\n        }\n        return this;\n      } else {\n        perm = this[permName];\n        for (i = u = 0, ref5 = maxOur; (0 <= ref5 ? u <= ref5 : u >= ref5); i = 0 <= ref5 ? ++u : --u) {\n          our[i] = -1;\n        }\n        a = b = x = 0;\n        // Compute the index a < ((maxAll + 1) choose (maxOur + 1)) and\n        // the permutation\n        if (fromEnd) {\n          for (j = w = ref6 = maxAll; (ref6 <= 0 ? w <= 0 : w >= 0); j = ref6 <= 0 ? ++w : --w) {\n            if ((start <= (ref7 = perm[j]) && ref7 <= end)) {\n              a += Cnk(maxAll - j, x + 1);\n              our[maxOur - x] = perm[j];\n              x++;\n            }\n          }\n        } else {\n          for (j = y = 0, ref8 = maxAll; (0 <= ref8 ? y <= ref8 : y >= ref8); j = 0 <= ref8 ? ++y : --y) {\n            if ((start <= (ref9 = perm[j]) && ref9 <= end)) {\n              a += Cnk(j, x + 1);\n              our[x] = perm[j];\n              x++;\n            }\n          }\n        }\n// Compute the index b < (maxOur + 1)! for the permutation\n        for (j = z = ref10 = maxOur; (ref10 <= 0 ? z <= 0 : z >= 0); j = ref10 <= 0 ? ++z : --z) {\n          k = 0;\n          while (our[j] !== start + j) {\n            rotateLeft(our, 0, j);\n            k++;\n          }\n          b = (j + 1) * b + k;\n        }\n        return a * maxB + b;\n      }\n    };\n  };\n\n  Include = {\n    // The twist of the 8 corners, 0 <= twist < 3^7. The orientation of\n    // the DRB corner is fully determined by the orientation of the other\n    // corners.\n    twist: function(twist) {\n      var i, m, o, ori, parity, v;\n      if (twist != null) {\n        parity = 0;\n        for (i = m = 6; m >= 0; i = --m) {\n          ori = twist % 3;\n          twist = (twist / 3) | 0;\n          this.co[i] = ori;\n          parity += ori;\n        }\n        this.co[7] = (3 - parity % 3) % 3;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 6; i = ++o) {\n          v = 3 * v + this.co[i];\n        }\n        return v;\n      }\n    },\n    // The flip of the 12 edges, 0 <= flip < 2^11. The orientation of the\n    // BR edge is fully determined by the orientation of the other edges.\n    flip: function(flip) {\n      var i, m, o, ori, parity, v;\n      if (flip != null) {\n        parity = 0;\n        for (i = m = 10; m >= 0; i = --m) {\n          ori = flip % 2;\n          flip = flip / 2 | 0;\n          this.eo[i] = ori;\n          parity += ori;\n        }\n        this.eo[11] = (2 - parity % 2) % 2;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 10; i = ++o) {\n          v = 2 * v + this.eo[i];\n        }\n        return v;\n      }\n    },\n    // Parity of the corner permutation\n    cornerParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = DRB, ref1 = URF + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = URF; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.cp[j] > this.cp[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Parity of the edges permutation. Parity of corners and edges are\n    // the same if the cube is solvable.\n    edgeParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = BR, ref1 = UR + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = UR; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.ep[j] > this.ep[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Permutation of the six corners URF, UFL, ULB, UBR, DFR, DLF\n    URFtoDLF: permutationIndex('corners', URF, DLF),\n    // Permutation of the three edges UR, UF, UL\n    URtoUL: permutationIndex('edges', UR, UL),\n    // Permutation of the three edges UB, DR, DF\n    UBtoDF: permutationIndex('edges', UB, DF),\n    // Permutation of the six edges UR, UF, UL, UB, DR, DF\n    URtoDF: permutationIndex('edges', UR, DF),\n    // Permutation of the equator slice edges FR, FL, BL and BR\n    FRtoBR: permutationIndex('edges', FR, BR, true)\n  };\n\n  for (key in Include) {\n    value = Include[key];\n    Cube.prototype[key] = value;\n  }\n\n  computeMoveTable = function(context, coord, size) {\n    var apply, cube, i, inner, j, k, m, move, o, p, ref, results;\n    // Loop through all valid values for the coordinate, setting cube's\n    // state in each iteration. Then apply each of the 18 moves to the\n    // cube, and compute the resulting coordinate.\n    apply = context === 'corners' ? 'cornerMultiply' : 'edgeMultiply';\n    cube = new Cube;\n    results = [];\n    for (i = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n      cube[coord](i);\n      inner = [];\n      for (j = o = 0; o <= 5; j = ++o) {\n        move = Cube.moves[j];\n        for (k = p = 0; p <= 2; k = ++p) {\n          cube[apply](move);\n          inner.push(cube[coord]());\n        }\n        // 4th face turn restores the cube\n        cube[apply](move);\n      }\n      results.push(inner);\n    }\n    return results;\n  };\n\n  // Because we only have the phase 2 URtoDF coordinates, we need to\n  // merge the URtoUL and UBtoDF coordinates to URtoDF in the beginning\n  // of phase 2.\n  mergeURtoDF = (function() {\n    var a, b;\n    a = new Cube;\n    b = new Cube;\n    return function(URtoUL, UBtoDF) {\n      var i, m;\n      // Collisions can be found because unset are set to -1\n      a.URtoUL(URtoUL);\n      b.UBtoDF(UBtoDF);\n      for (i = m = 0; m <= 7; i = ++m) {\n        if (a.ep[i] !== -1) {\n          if (b.ep[i] !== -1) {\n            return -1; // collision\n          } else {\n            b.ep[i] = a.ep[i];\n          }\n        }\n      }\n      return b.URtoDF();\n    };\n  })();\n\n  N_TWIST = 2187; // 3^7 corner orientations\n\n  N_FLIP = 2048; // 2^11 possible edge flips\n\n  N_PARITY = 2; // 2 possible parities\n\n  N_FRtoBR = 11880; // 12!/(12-4)! permutations of FR..BR edges\n\n  N_SLICE1 = 495; // (12 choose 4) possible positions of FR..BR edges\n\n  N_SLICE2 = 24; // 4! permutations of FR..BR edges in phase 2\n\n  N_URFtoDLF = 20160; // 8!/(8-6)! permutations of URF..DLF corners\n\n  \n  // The URtoDF move table is only computed for phase 2 because the full\n  // table would have >650000 entries\n  N_URtoDF = 20160; // 8!/(8-6)! permutation of UR..DF edges in phase 2\n\n  N_URtoUL = 1320; // 12!/(12-3)! permutations of UR..UL edges\n\n  N_UBtoDF = 1320; // 12!/(12-3)! permutations of UB..DF edges\n\n  \n  // The move table for parity is so small that it's included here\n  Cube.moveTables = {\n    parity: [[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]],\n    twist: null,\n    flip: null,\n    FRtoBR: null,\n    URFtoDLF: null,\n    URtoDF: null,\n    URtoUL: null,\n    UBtoDF: null,\n    mergeURtoDF: null\n  };\n\n  // Other move tables are computed on the fly\n  moveTableParams = {\n    // name: [scope, size]\n    twist: ['corners', N_TWIST],\n    flip: ['edges', N_FLIP],\n    FRtoBR: ['edges', N_FRtoBR],\n    URFtoDLF: ['corners', N_URFtoDLF],\n    URtoDF: ['edges', N_URtoDF],\n    URtoUL: ['edges', N_URtoUL],\n    UBtoDF: ['edges', N_UBtoDF],\n    mergeURtoDF: []\n  };\n\n  Cube.computeMoveTables = function(...tables) {\n    var len, m, name, scope, size, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in moveTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.moveTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      if (tableName === 'mergeURtoDF') {\n        this.moveTables.mergeURtoDF = (function() {\n          var UBtoDF, URtoUL, o, results;\n          results = [];\n          for (URtoUL = o = 0; o <= 335; URtoUL = ++o) {\n            results.push((function() {\n              var p, results1;\n              results1 = [];\n              for (UBtoDF = p = 0; p <= 335; UBtoDF = ++p) {\n                results1.push(mergeURtoDF(URtoUL, UBtoDF));\n              }\n              return results1;\n            })());\n          }\n          return results;\n        })();\n      } else {\n        [scope, size] = moveTableParams[tableName];\n        this.moveTables[tableName] = computeMoveTable(scope, tableName, size);\n      }\n    }\n    return this;\n  };\n\n  // Phase 1: All moves are valid\n  allMoves1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];\n\n  // The list of next valid phase 1 moves when the given face was turned\n  // in the last move\n  nextMoves1 = (function() {\n    var face, lastFace, m, next, o, p, power, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n// Don't allow commuting moves, e.g. U U'. Also make sure that\n// opposite faces are always moved in the same order, i.e. allow\n// U D but no D U. This avoids sequences like U D U'.\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (face !== lastFace && face !== lastFace - 3) {\n// single, double or inverse move\n          for (power = p = 0; p <= 2; power = ++p) {\n            next.push(face * 3 + power);\n          }\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // Phase 2: Double moves of all faces plus quarter moves of U and D\n  allMoves2 = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];\n\n  nextMoves2 = (function() {\n    var face, lastFace, len, m, next, o, p, power, powers, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (!(face !== lastFace && face !== lastFace - 3)) {\n          continue;\n        }\n        // Allow all moves of U and D and double moves of others\n        powers = face === 0 || face === 3 ? [0, 1, 2] : [1];\n        for (p = 0, len = powers.length; p < len; p++) {\n          power = powers[p];\n          next.push(face * 3 + power);\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // 8 values are encoded in one number\n  pruning = function(table, index, value) {\n    var pos, shift, slot;\n    pos = index % 8;\n    slot = index >> 3;\n    shift = pos << 2;\n    if (value != null) {\n      // Set\n      table[slot] &= ~(0xF << shift);\n      table[slot] |= value << shift;\n      return value;\n    } else {\n      // Get\n      return (table[slot] & (0xF << shift)) >>> shift;\n    }\n  };\n\n  computePruningTable = function(phase, size, currentCoords, nextIndex) {\n    var current, depth, done, index, len, m, move, moves, next, o, ref, table, x;\n    // Initialize all values to 0xF\n    table = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = Math.ceil(size / 8) - 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(0xFFFFFFFF);\n      }\n      return results;\n    })();\n    if (phase === 1) {\n      moves = allMoves1;\n    } else {\n      moves = allMoves2;\n    }\n    depth = 0;\n    pruning(table, 0, depth);\n    done = 1;\n    // In each iteration, take each state found in the previous depth and\n    // compute the next state. Stop when all states have been assigned a\n    // depth.\n    while (done !== size) {\n      for (index = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); index = 0 <= ref ? ++m : --m) {\n        if (!(pruning(table, index) === depth)) {\n          continue;\n        }\n        current = currentCoords(index);\n        for (o = 0, len = moves.length; o < len; o++) {\n          move = moves[o];\n          next = nextIndex(current, move);\n          if (pruning(table, next) === 0xF) {\n            pruning(table, next, depth + 1);\n            done++;\n          }\n        }\n      }\n      depth++;\n    }\n    return table;\n  };\n\n  Cube.pruningTables = {\n    sliceTwist: null,\n    sliceFlip: null,\n    sliceURFtoDLFParity: null,\n    sliceURtoDFParity: null\n  };\n\n  pruningTableParams = {\n    // name: [phase, size, currentCoords, nextIndex]\n    sliceTwist: [\n      1,\n      N_SLICE1 * N_TWIST,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var newSlice,\n      newTwist,\n      slice,\n      twist;\n        [slice,\n      twist] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newTwist = Cube.moveTables.twist[twist][move];\n        return newTwist * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceFlip: [\n      1,\n      N_SLICE1 * N_FLIP,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var flip,\n      newFlip,\n      newSlice,\n      slice;\n        [slice,\n      flip] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newFlip = Cube.moveTables.flip[flip][move];\n        return newFlip * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceURFtoDLFParity: [\n      2,\n      N_SLICE2 * N_URFtoDLF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URFtoDLF,\n      newParity,\n      newSlice,\n      newURFtoDLF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URFtoDLF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];\n        return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ],\n    sliceURtoDFParity: [\n      2,\n      N_SLICE2 * N_URtoDF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URtoDF,\n      newParity,\n      newSlice,\n      newURtoDF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URtoDF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];\n        return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ]\n  };\n\n  Cube.computePruningTables = function(...tables) {\n    var len, m, name, params, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in pruningTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.pruningTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      params = pruningTableParams[tableName];\n      this.pruningTables[tableName] = computePruningTable(...params);\n    }\n    return this;\n  };\n\n  Cube.initSolver = function() {\n    Cube.computeMoveTables();\n    return Cube.computePruningTables();\n  };\n\n  Cube.prototype.solveUpright = function(maxDepth = 22) {\n    var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;\n    // Names for all moves, i.e. U, U2, U', F, F2, ...\n    moveNames = (function() {\n      var face, faceName, m, o, power, powerName, result;\n      faceName = ['U', 'R', 'F', 'D', 'L', 'B'];\n      powerName = ['', '2', \"'\"];\n      result = [];\n      for (face = m = 0; m <= 5; face = ++m) {\n        for (power = o = 0; o <= 2; power = ++o) {\n          result.push(faceName[face] + powerName[power]);\n        }\n      }\n      return result;\n    })();\n    State = class State {\n      constructor(cube) {\n        this.parent = null;\n        this.lastMove = null;\n        this.depth = 0;\n        if (cube) {\n          this.init(cube);\n        }\n      }\n\n      init(cube) {\n        // Phase 1 coordinates\n        this.flip = cube.flip();\n        this.twist = cube.twist();\n        this.slice = cube.FRtoBR() / N_SLICE2 | 0;\n        // Phase 2 coordinates\n        this.parity = cube.cornerParity();\n        this.URFtoDLF = cube.URFtoDLF();\n        this.FRtoBR = cube.FRtoBR();\n        // These are later merged to URtoDF when phase 2 begins\n        this.URtoUL = cube.URtoUL();\n        this.UBtoDF = cube.UBtoDF();\n        return this;\n      }\n\n      solution() {\n        if (this.parent) {\n          return this.parent.solution() + moveNames[this.lastMove] + ' ';\n        } else {\n          return '';\n        }\n      }\n\n      //# Helpers\n      move(table, index, move) {\n        return Cube.moveTables[table][index][move];\n      }\n\n      pruning(table, index) {\n        return pruning(Cube.pruningTables[table], index);\n      }\n\n      //# Phase 1\n\n      // Return the next valid phase 1 moves for this state\n      moves1() {\n        if (this.lastMove !== null) {\n          return nextMoves1[this.lastMove / 3 | 0];\n        } else {\n          return allMoves1;\n        }\n      }\n\n      // Compute the minimum number of moves to the end of phase 1\n      minDist1() {\n        var d1, d2;\n        // The maximum number of moves to the end of phase 1 wrt. the\n        // combination flip and slice coordinates only\n        d1 = this.pruning('sliceFlip', N_SLICE1 * this.flip + this.slice);\n        // The combination of twist and slice coordinates\n        d2 = this.pruning('sliceTwist', N_SLICE1 * this.twist + this.slice);\n        // The true minimal distance is the maximum of these two\n        return max(d1, d2);\n      }\n\n      // Compute the next phase 1 state for the given move\n      next1(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.flip = this.move('flip', this.flip, move);\n        next.twist = this.move('twist', this.twist, move);\n        next.slice = this.move('FRtoBR', this.slice * 24, move) / 24 | 0;\n        return next;\n      }\n\n      //# Phase 2\n\n      // Return the next valid phase 2 moves for this state\n      moves2() {\n        if (this.lastMove !== null) {\n          return nextMoves2[this.lastMove / 3 | 0];\n        } else {\n          return allMoves2;\n        }\n      }\n\n      // Compute the minimum number of moves to the solved cube\n      minDist2() {\n        var d1, d2, index1, index2;\n        index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;\n        d1 = this.pruning('sliceURtoDFParity', index1);\n        index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;\n        d2 = this.pruning('sliceURFtoDLFParity', index2);\n        return max(d1, d2);\n      }\n\n      // Initialize phase 2 coordinates\n      init2(top = true) {\n        if (this.parent === null) {\n          return;\n        }\n        // For other states, the phase 2 state is computed based on\n        // parent's state.\n        // Already assigned for the initial state\n        this.parent.init2(false);\n        this.URFtoDLF = this.move('URFtoDLF', this.parent.URFtoDLF, this.lastMove);\n        this.FRtoBR = this.move('FRtoBR', this.parent.FRtoBR, this.lastMove);\n        this.parity = this.move('parity', this.parent.parity, this.lastMove);\n        this.URtoUL = this.move('URtoUL', this.parent.URtoUL, this.lastMove);\n        this.UBtoDF = this.move('UBtoDF', this.parent.UBtoDF, this.lastMove);\n        if (top) {\n          // This is the initial phase 2 state. Get the URtoDF coordinate\n          // by merging URtoUL and UBtoDF\n          return this.URtoDF = this.move('mergeURtoDF', this.URtoUL, this.UBtoDF);\n        }\n      }\n\n      // Compute the next phase 2 state for the given move\n      next2(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.URFtoDLF = this.move('URFtoDLF', this.URFtoDLF, move);\n        next.FRtoBR = this.move('FRtoBR', this.FRtoBR, move);\n        next.parity = this.move('parity', this.parity, move);\n        next.URtoDF = this.move('URtoDF', this.URtoDF, move);\n        return next;\n      }\n\n    };\n    solution = null;\n    phase1search = function(state) {\n      var depth, m, ref, results;\n      depth = 0;\n      results = [];\n      for (depth = m = 1, ref = maxDepth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase1(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase1 = function(state, depth) {\n      var len, m, move, next, ref, ref1, results;\n      if (depth === 0) {\n        if (state.minDist1() === 0) {\n          // Make sure we don't start phase 2 with a phase 2 move as the\n          // last move in phase 1, because phase 2 would then repeat the\n          // same move.\n          if (state.lastMove === null || (ref = state.lastMove, indexOf.call(allMoves2, ref) < 0)) {\n            return phase2search(state);\n          }\n        }\n      } else if (depth > 0) {\n        if (state.minDist1() <= depth) {\n          ref1 = state.moves1();\n          results = [];\n          for (m = 0, len = ref1.length; m < len; m++) {\n            move = ref1[m];\n            next = state.next1(move);\n            phase1(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    phase2search = function(state) {\n      var depth, m, ref, results;\n      // Initialize phase 2 coordinates\n      state.init2();\n      results = [];\n      for (depth = m = 1, ref = maxDepth - state.depth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase2(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase2 = function(state, depth) {\n      var len, m, move, next, ref, results;\n      if (depth === 0) {\n        if (state.minDist2() === 0) {\n          return solution = state.solution();\n        }\n      } else if (depth > 0) {\n        if (state.minDist2() <= depth) {\n          ref = state.moves2();\n          results = [];\n          for (m = 0, len = ref.length; m < len; m++) {\n            move = ref[m];\n            next = state.next2(move);\n            phase2(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    freeStates = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = maxDepth + 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(new State);\n      }\n      return results;\n    })();\n    state = freeStates.pop().init(this);\n    phase1search(state);\n    freeStates.push(state);\n    // Trim the trailing space\n    if (solution.length > 0) {\n      solution = solution.substring(0, solution.length - 1);\n    }\n    return solution;\n  };\n\n  faceNums = {\n    U: 0,\n    R: 1,\n    F: 2,\n    D: 3,\n    L: 4,\n    B: 5\n  };\n\n  faceNames = {\n    0: 'U',\n    1: 'R',\n    2: 'F',\n    3: 'D',\n    4: 'L',\n    5: 'B'\n  };\n\n  Cube.prototype.solve = function(maxDepth = 22) {\n    var clone, len, m, move, ref, rotation, solution, upright, uprightSolution;\n    clone = this.clone();\n    upright = clone.upright();\n    clone.move(upright);\n    rotation = new Cube().move(upright).center;\n    uprightSolution = clone.solveUpright(maxDepth);\n    solution = [];\n    ref = uprightSolution.split(' ');\n    for (m = 0, len = ref.length; m < len; m++) {\n      move = ref[m];\n      solution.push(faceNames[rotation[faceNums[move[0]]]]);\n      if (move.length > 1) {\n        solution[solution.length - 1] += move[1];\n      }\n    }\n    return solution.join(' ');\n  };\n\n  Cube.scramble = function() {\n    return Cube.inverse(Cube.random().solve());\n  };\n\n}).call(this);\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","B","BL","BR","Cube","D","DB","DBL","DF","DFR","DL","DLF","DR","DRB","F","FL","FR","L","R","U","UB","UBR","UF","UFL","UL","ULB","UR","URF","centerColor","centerFacelet","cornerColor","cornerFacelet","edgeColor","edgeFacelet","_B","_D","_F","_L","_R","_U","x","faceNames","faceNums","parseAlg","generateValidRandomOrientation","generateValidRandomPermutation","getNumSwaps","isOrientationValid","randint","randomizeOrientation","shuffle","constructor","other","identity","newCenter","k","results","push","newCp","newEp","newCo","newEo","state","center","slice","co","ep","cp","eo","toJSON","asString","corner","edge","i","l","m","n","o","ori","p","result","join","fromString","str","col1","col2","cube","j","q","r","ref","clone","random","randomize","isSolved","c","cent","e","move","upright","centerMultiply","from","to","cornerMultiply","edgeMultiply","multiply","arg","face","len","power","length","moves","inverse","reverse","substring","prototype","min","max","Math","floor","array","currentIndex","randomIndex","arr","cur","cycleLength","numSwaps","seen","numOrientations","reduce","a","b","E","M","S","y","z","u","f","d","part","split","$e46aab79b15c8453$exports","Cnk","Include","allMoves1","allMoves2","computeMoveTable","computePruningTable","factorial","key","mergeURtoDF","moveTableParams","nextMoves1","nextMoves2","permutationIndex","pruning","pruningTableParams","rotateLeft","rotateRight","value","indexOf","s","ref1","tmp","twist","parity","v","flip","cornerParity","ref2","edgeParity","URFtoDLF","context","start","end","fromEnd","maxAll","maxB","maxOur","our","permName","index","perm","ref3","ref4","ref6","ref7","ref8","ref9","t","w","ref10","URtoUL","UBtoDF","URtoDF","FRtoBR","coord","size","apply","inner","moveTables","computeMoveTables","tables","name","scope","tableName","results1","lastFace","next","powers","table","shift","slot","pos","phase","currentCoords","nextIndex","current","depth","done","ceil","pruningTables","sliceTwist","sliceFlip","sliceURFtoDLFParity","sliceURtoDFParity","N_SLICE1","newSlice","newTwist","newFlip","N_SLICE2","newParity","newURFtoDLF","newURtoDF","computePruningTables","params","initSolver","solveUpright","maxDepth","State","freeStates","moveNames","phase1","phase2","phase2search","solution","faceName","powerName","parent","lastMove","moves1","minDist1","next1","pop","moves2","minDist2","d1","index1","index2","init2","top","next2","phase1search","solve","rotation","uprightSolution","scramble","$9495dc782b1de45f$var$init","__esModule","default","document","querySelector","textContent"],"version":3,"file":"index.e65b56a2.js.map"}